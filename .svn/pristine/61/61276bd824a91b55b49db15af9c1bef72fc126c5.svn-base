# -- coding: utf-8 --
import robot
import plc_tb_ctrl
import concentrator
import meter
import tc_common
import plc_packet_helper
import time

'''
1. 连接设备，将待测 STA 上电初始化；
2. 软件平台模拟电表，在收到待测 STA 的读表号请求后，向其下发表地址；
3. 软件平台模拟 CCO 周期性向待测 STA 设备发送“中央信标” ，前 5 个信标周期中，信
标帧载荷“开始关联标志位”为 0，查看站点是否发起关联，若收到关联请求则认为
不通过，输出测试不通过记录，测试结束；
4. 从第 6 个周期开始，信标帧载荷“开始关联标志位”为 1，同时启动定时器（定时时
长 15s），等待待测 STA 发出的“关联请求”报文；
5. 定时时间内软件平台若收不到站点发出的“关联请求”报文，则失败，若是收到，则
调用一致性评价模块，测试协议一致性，若一致则通过，若不一致，则测试不通过。
'''
def run(tb):
    """
    Args:
        tb (plc_tb_ctrl.PlcSystemTestbench): testbench object .
    """
    assert isinstance(tb, plc_tb_ctrl.PlcSystemTestbench),"tb type is not plc_tb_ctrl.PlcSystemTestbench"
    m = meter.Meter()
    m.open_port()

    tc_common.activate_tb(tb,work_band = 1)

    #wait for meter read request
    dlt645_frame = m.wait_for_dlt645_frame(code = 'DATA_READ', dir = 'REQ_FRAME', timeout = 10)

    plc_tb_ctrl._debug(dlt645_frame)
    assert dlt645_frame.head.len == 4
    assert dlt645_frame.head.addr.upper() == 'AA-AA-AA-AA-AA-AA'


    #prepare reply frame for meter read request
    meter_addr = '12-34-56-78-90-12'
    reply_data = [1,2,3,4]
    dis = [dlt645_frame.body.value.DI0,
           dlt645_frame.body.value.DI1,
           dlt645_frame.body.value.DI2,
           dlt645_frame.body.value.DI3]


    tc_common.send_dlt645_reply_frame(m,meter_addr,dis,reply_data,len(reply_data))

    #send beacon periodically
    beacon_dict = tb._load_data_file('tb_beacon_data.yaml')
    beacon_dict['num'] = 5
    beacon_dict['payload']['value']['association_start'] = 0

    tb._configure_beacon(None, beacon_dict)

    #how long should we wait
    waiting_time = beacon_dict['num']*beacon_dict['period']/1000

    plc_tb_ctrl._debug('waiting time:{}'.format(waiting_time))
    ret = tb._wait_for_plc_nmm('MME_ASSOC_REQ',waiting_time, (lambda:None))
    assert ret is None

    #we should not receive association request
    beacon_dict['num'] = 20
    beacon_dict['payload']['value']['association_start'] = 1
    tb._configure_beacon(None, beacon_dict)

    [fc, mac_frame_head, nmm] = tb._wait_for_plc_nmm('MME_ASSOC_REQ',15)

    #whether received associated request or not, stop beacon scheduling
    beacon_dict['num'] = 0
    tb._configure_beacon(None, beacon_dict)



    assert nmm.body.mac == meter_addr
    assert nmm.body.proxy_tei[0] == 1
    assert nmm.body.mac_addr_type == 'MAC_ADDR_TYPE_METER_ADDRESS'



    m.close_port()






