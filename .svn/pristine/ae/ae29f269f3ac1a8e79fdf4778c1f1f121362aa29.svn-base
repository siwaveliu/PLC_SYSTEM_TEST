# -- coding: utf-8 --
import robot
import plc_tb_ctrl
import concentrator
import meter
import tc_common
import plc_packet_helper
import time

'''
1. 连接设备，将待测 STA 上电初始化；
2. 软件平台模拟电表，在收到待测 STA 的读表号请求后，向其下发表地址；
3. 软件平台模拟 CCO 周期性向待测 STA 设备发送“中央信标” 帧，收到“关联请求”
帧后，回复“关联确认” 帧，使站点入网成功；
4. 软件平台模拟 CCO 发送安排站点发送发现信标时隙的“中央信标”帧，启动定时时
间 15s,定时时间内软件平台若收不到站点发出的“发现信标”报文，则失败，若是
收到，则调用一致性评价模块，测试协议一致性，若不一致，则输出不通过；
5. 软件平台模拟 STA 发送“关联请求”，启动定时时间 15s,定时时间内收不到待测 STA
转发的“关联请求” 帧，则不通过，若收到，则调用一致性评价模块，测试协议一
致性，若不一致，则输出不通过；
6. 软件平台模拟 CCO 发送“关联确认”，启动定时时间 10s，定时时间内收不到待测 STA
转发的“关联确认”帧，则不通过，若收到，则调用一致性评价模块，测试协议一
致性，不一致则输出不通过，一致则测试通过。
'''
def run(tb):
    """
    Args:
        tb (plc_tb_ctrl.PlcSystemTestbench): testbench object .
    """
    assert isinstance(tb, plc_tb_ctrl.PlcSystemTestbench),"tb type is not plc_tb_ctrl.PlcSystemTestbench"
    m = meter.Meter();
    m.open_port()

    tc_common.activate_tb(tb,work_band = 1)

    #wait for meter read request
    dlt645_frame = m.wait_for_dlt645_frame(code = 'DATA_READ', dir = 'REQ_FRAME', timeout = 10)

    #plc_tb_ctrl._debug(dlt645_frame)
    assert dlt645_frame.head.len == 4
    assert dlt645_frame.head.addr.upper() == 'AA-AA-AA-AA-AA-AA'

    cco_mac = '00-00-C0-A8-01-01'

    #prepare reply frame for meter read request
    meter_addr = '12-34-56-78-90-12'
    reply_data = [1,2,3,4]
    dis = [dlt645_frame.body.value.DI0,
           dlt645_frame.body.value.DI1,
           dlt645_frame.body.value.DI2,
           dlt645_frame.body.value.DI3]


    tc_common.send_dlt645_reply_frame(m,meter_addr,dis,reply_data,len(reply_data))

    #send center beacon periodically
    #proxy_tei = 14
    beacon_dict = tb._load_data_file('tb_beacon_data.yaml')
    beacon_dict['payload']['value']['association_start'] = 1
    tb._configure_beacon(None, beacon_dict)
    
    #config nid and nw_sn for sending of mpdu
    tb._configure_nw_static_para(beacon_dict['fc']['nid'], beacon_dict['payload']['value']['nw_sn'])
    
    [fc, mac_frame_head, nmm] = tb._wait_for_plc_nmm('MME_ASSOC_REQ',15)


    time.sleep(2)
    tb.tb_uart.clear_tb_port_rx_buf()
    #send associate confirm to STA
    asso_cnf_dict = tb._load_data_file('nml_assoc_cnf_9.yaml')
    asso_cnf_dict['body']['mac_sta'] = meter_addr
    asso_cnf_dict['body']['mac_cco'] = cco_mac
    asso_cnf_dict['body']['p2p_sn'] = nmm.body.p2p_sn

    #config the mac header
    tb.mac_head.org_dst_tei = 0
    tb.mac_head.org_src_tei = 1
    tb.mac_head.mac_addr_flag = 1
    tb.mac_head.src_mac_addr = cco_mac
    tb.mac_head.dst_mac_addr = meter_addr
    tb.mac_head.tx_type = 'PLC_LOCAL_BROADCAST'
    tb.mac_head.msdu_type = "PLC_MSDU_TYPE_NMM"
    msdu = plc_packet_helper.build_nmm(asso_cnf_dict)
    
    #tb._configure_nw_static_para(nid, nw_org_sn)
    tb._send_msdu(msdu, tb.mac_head, src_tei = 1, dst_tei = 0,broadcast_flag = 1)


    #sleep 2 seconds for this beacon period to complete, and begin new beacon scheduling
    #in this central beacon, discovering beacon slot is reserved for tei2
    #time.sleep(2)
    beacon_dict = tb._load_data_file('tb_beacon_data_9.yaml')
    tb._configure_beacon(None, beacon_dict,True)

    #wait for discovering beacon comming from DUT
    [beacon_fc, beacon_payload] = tb._wait_for_plc_beacon(15)[1:]

    #check parameters inside the discover beacon
    assert beacon_payload.beacon_type == 'DISCOVERY_BEACON'
    assert beacon_payload.beacon_info.beacon_item_list[0].beacon_item.level == 1
    assert beacon_payload.beacon_info.beacon_item_list[0].beacon_item.proxy_tei == 1
    assert beacon_payload.beacon_info.beacon_item_list[0].beacon_item.mac == meter_addr
    assert beacon_payload.beacon_info.beacon_item_list[0].beacon_item.role == 'STA_ROLE_STATION'
    assert beacon_payload.beacon_info.beacon_item_list[0].beacon_item.sta_tei == 2



    #send association request to DUT (mac address is not in the white list)
    tb.mac_head.org_dst_tei = 1
    tb.mac_head.org_src_tei = 0
    tb.mac_head.mac_addr_flag = 0
    tb.mac_head.hop_limit = 2
    tb.mac_head.remaining_hop_count = 2
#     tb.mac_head.src_mac_addr = '1-2-3-4-5-6'
#     tb.mac_head.dst_mac_addr = meter_addr
    tb.mac_head.tx_type = 'PLC_MAC_UNICAST'
    tb._send_nmm('nml_assoc_req_9.yaml', tb.mac_head, src_tei = 0,dst_tei = 2)

    #wait for the relayed associated request coming from DUT
    [fc, mac_frame_head, nmm] = tb._wait_for_plc_nmm('MME_ASSOC_REQ',15)



    time.sleep(0.5)
    #send associated confirm (for STA level 2) to DUT and hope it can be relayed to the level 2 STA
    asso_cnf_dict = tb._load_data_file('nml_assoc_cnf_9.yaml')
    asso_cnf_dict['body']['mac_sta'] = nmm.body.mac
    asso_cnf_dict['body']['mac_cco'] = cco_mac
    asso_cnf_dict['body']['level'] = 2
    asso_cnf_dict['body']['tei_sta'] = 3
    asso_cnf_dict['body']['tei_proxy'] = 2
    asso_cnf_dict['body']['p2p_sn'] = nmm.body.p2p_sn

    msdu = plc_packet_helper.build_nmm(asso_cnf_dict)

    #config the mac header
    tb.mac_head.org_dst_tei = 2
    tb.mac_head.org_src_tei = 1
    tb.mac_head.hop_limit = 1
    tb.mac_head.remaining_hop_count = 1
    tb._send_msdu(msdu, tb.mac_head, src_tei = 1, dst_tei = 2)

    #wait for the relayed association confirm
    [fc, mac_frame_head, nmm] = tb._wait_for_plc_nmm('MME_ASSOC_CNF',10)


    assert fc.var_region_ver.src_tei == 2
    assert fc.var_region_ver.broadcast_flag == 1
    assert mac_frame_head.tx_type == 'PLC_LOCAL_BROADCAST'
    assert mac_frame_head.hop_limit == 1
    assert mac_frame_head.remaining_hop_count == 1
    assert mac_frame_head.mac_addr_flag == 1
    assert mac_frame_head.dst_mac_addr == asso_cnf_dict['body']['mac_sta']


    assert 0 == cmp(asso_cnf_dict['body'],nmm.body)
    
    




    m.close_port()






